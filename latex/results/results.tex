\chapter{Identifikation von Angriffszielen}
\label{chapter:results}

\section{RSA Key Generierung}

Frühere Arbeiten zu Cache-Angriffen hatten es vor allem auf die Verschlüsselung- und Enschlüsselungsroutionen der RSA-Implementierungen abgesehen \cite{FlushReload, CacheBleedOpenSSLRSA}, weshalb diese Routinen besonders gehärtet und geprüft sind.
Ein andereren Einstiegspunkt für die Schlüsselextraktion bieteten die Routienen zur Schlüsselserzeugung, welche erst in den letzten Monat in Arbeiten näher untersucht wurden.

\subsection{Primzahlgenerierung in Mozilla NSS}

Um einen neuen Schlüssel zu erzeugen werden zuerst zwei Primzahlen erzeugt. Im Folgenden soll die Primzahlgenerierung von Mozilla NSS näher beleuchtet werden.
Der Einstiegspunkt für die Primezahlgenerierung ist die Funktion generate_prime in der Datei rsa.c \ref{alg:genPrimeGenerationNSS}.
Dort wird zuerst eine ungerade Zufallszahl $random\_num$ entsprechend der Bitlänge der gewünschten Primzahl erzeugt, deren zwei höherwertigsten Bits auf 1 gesetzt sind.
Anschließend wird versucht auf Basis von $random\_num$ eine Primzahl zu erzeugen und diese im Erfolgsfall zurückgegeben.
Falls dies fehlschlägt wird der gesamte Vorgang bis zu 10 mal wiederholt bis die Primzahlgenerierung endgültig abgebrochen wird.

\begin{algorithm}[h]
\DontPrintSemicolon
\caption{Pseudo-Code für generate_prime in Mozilla NSS}
\label{alg:genPrimeGenerationNSS}

\Fn{$generate_prime(primeLen)$}{
    \For{1 to 10}{
        random\_num <- RNG_GenerateGlobalRandomBytes(primeLen)\;
        random\_num[0] |= 0xC0            /* set two high-order bits */\;
        random\_num[primeLen - 1] |= 0x01 /* set low-order bit       */\;
        successful <- mpp_make_prime(random\_num, \&prime)\;
        \If{successful}{
            \Return prime\;
        }
    }
    \Return no prime found
}
\end{algorithm}

Die Zahl $random\_num$ wird an die Funktion mpp_make_prime in der Datei mpprime.c übergeben \ref{alg:makePrimeGenerationNSS}.
Global definiert ist das Array $primes_tab$, das alle Primzahlen von 3 bis 2^16 beinhaltet. Dieses Array wird nicht dynamisch beim Start erzeugt, stattdessen stehen alle benötigten Primzahlen fix im Quellcode. 
Das Array $primes_tab$ wird im folgenden Siebvorgang benötigt, um mit wenig Rechenleistung eine Reihe von Primzahlkandidaten auszuschließen.
Dieser Siebvorgang wird in der Funktion mpp_sieve, ebenfalls in mpprime.c zu finden, definiert \ref{alg:sievePrimeGenerationNSS}.
Zahlen der Form $random\_num + 2 \cdot i$, mit $i \in \{1,...,SIEVE\_SIZE\}$ sind mögliche Primzahlkandidaten.
Die später verwendeten Fermat- und Miller-Rabin-Tests sind relativ aufwendig, weswegen ein Siebvorgang analog zum Sieb des Eratosthenes vorangestellt wird.
Im Siebvorgang wird über alle Primzahlen im $primes_tab$-Array iteriert und jeweils der Rest $rem$ von $random\_num$$\mod$$small\_prime$ errechnet.

Durch den Aufruf von $mp_mod_d$ im Pseudocode in Zeile 4 wird angedeutet, dass diese Modulo-Operation nicht in einen einzigen Maschinenbefehl übersetzt werden kann, da die Zahl random\_num nicht in ein Register passt. Anders hingegen ist dies bei der Modulo-Operation in Zeile 10, da dort sowohl $i$ als auch 2 in ein Register passen.

Nun müssen zwei Fälle unterschieden werden:
Im ersten Fall sei $random\_num$ durch $small\_prime$ teilbar, das heißt $random\_num$$\mod$$small\_prime = 0$.
Dann ist $random\_num$ zusammengesetzt, sowie auch alle $random\_num + k \cdot small\_prime$ mit $k \in \mathbb{N}$.
Das $sieve$-Array dient später um die Primzahlkandidaten der Form $random\_num + 2 \cdot i$ mit $i \in \{1,...,SIEVE\_SIZE\}$ zu erzeugen, wobei Kandidat $i$ nicht weiter betrachtet wird, wenn $sieve[i]$ auf $1$ gesetzt ist.

Im ersten Fall muss also $sieve[0] = 1$ gesetzt werden, da $random\_num \mod small\_prime = 0$.
Dies wird in der ersten Iteration der For-Schleife in Zeile 9 umgesetzt.
Außerdem muss $sieve[j] = 1$ gesetzt werden, falls $j = k \cdot small\_prime / 2$ gilt, da wie oben festgestellt $random\_num + k \cdot small\_prime$ bzw. $random\_num + 2 \cdot j$ zusammengesetzt ist.
Jenes wird in den restlichen Iterationen der For-Schleife umgesetzt, wobei Einträge im $sieve$-Array nur gesetzt werden, wenn $k \cdot small\_prime$ gerade ist.
Ungearde $k \cdot small\_prime$ sind uninteressant, da $random\_num$ ebenfalls ungerade ist und somit $random\_num + k \cdot small\_prime$ immer mindestens durch $2$ teilbar ist.

Im zweiten Fall sei $random\_num$ nicht durch $small\_prime$ teilbar, das heißt $rem \neq 0$.
Dann ist die Zahl $random\_num + (small\_prime - rem)$ durch $small\_prime$ teilbar, da $random\_num + (small\_prime - rem) \mod small\_prime = (random\_num \mod small\_prime + (small\_prime - rem)) \mod small\_prime = (rem + (small\_prime - rem)) = 0$.

Deshalb wird in der ersten Iteration der For-Schleife in Zeile 9 $sieve[(small\_prime - rem)/2] = 1$ gesetzt, unter der Bedingung das $(small\_prime - rem)/2$ gerade ist.
Zudem sind alle $random\_num + (small\_prime - rem) + k \cdot small\_prime$ durch $small\_prime$ teilbar, womit analog zu Fall 1 alle $sieve[j] = 1$ gesetzt werden, falls $j = ((small\_prime - rem) + k \cdot small\_prime) / 2$ ist.



\begin{algorithm}[h]
\DontPrintSemicolon
\caption{Pseudo-Code für mpp_sieve in Mozilla NSS}
\label{alg:sievePrimeGenerationNSS}
\Fn{$mpp\_sieve(random\_num, primes_tab, size)$}{
    
    \For{ix = 0; ix < nPrimes; ix++} {
        small\_prime <- primes_tab[ix]\;
        rem <- mp_mod_d(random\_num, small\_prime)\;

        \If{rem == 0}{
            offset = 0\;
        } 
        \Else {
            offset = small\_prime - rem\;
        }

        \For{i = offset; i < nSieve * 2; i += prime}{
            \If{i mod 2 == 0}{
                sieve[i / 2] = 1\;
            }
        }
    }
}
\end{algorithm}

Nachdem der Siebvorgang abgeschlossen ist, wird das $sieve$-Array in der Foreach-Schleife in Zeile 6 der Funktion mpp_make_prime verwendet.
Wie eben beschrieben können Kandidaten der Form $random\_num + 2 \cdot i$ ausgeschlossen werden, wenn $sieve[i] = 1$ gesetzt ist.
Die restlichen Kandidaten werden mittels des Fermat- und Miller-Rabin-Tests auf Primzahleigenschaft hin überprüft.
Werden auch diese Tests bestanden, wird die Zahl als Primzahl eingestuft und zurückgegeben.

\begin{algorithm}[h]
\DontPrintSemicolon
\caption{Pseudo-Code für mpp_make_prime in Mozilla NSS}
\label{alg:makePrimeGenerationNSS}
primes_tab <- [2, 3, 5, 7, ..., 65521] // 6541 primes from 3 to 2^16\;
SIEVE_SIZE <- 32 * 1024\;

\Fn{$mpp\_make\_prime(random\_num)$}{
    num_miller_rabin_tests <- get_num_tests(bitlen(random\_num)) // augmented by FIPS-186 requirements, Table C.2 and C.3

    sieve <- mpp_sieve(random\_num, prime_tab, SIEVE_SIZE)\;
    \ForEach{i in SIEVE_SIZE}{
        \If{sieve[i]}{ /*number is composite*/\;
            continue\;
        }
        probablePrime <- random\_num + 2*i\;
        \If{!mpp_fermat(probablePrime, 2)}{ //Fermat test with 2
            continue\;
        }
        \If{!mpp_pprime(probablePrime, num_tests)}{ //Miller Rabin test
            continue;
        }
        \Return probablePrime
    }
}
\end{algorithm}

\subsection{Primzahlgenerierung in OpenPGPjs}

Die Primzahlgenerierung von OpenPGPjs ist in der Datei prime.js beschrieben und startet mit der Funktion randomProbablePrime.
Zuerst wird eine Zufallszahl entsprechend der gewünschten Bitlänge generiert.
In OpenPGPjs wird kein Siebverfahren wie in Mozilla NSS angewandt, sondern es wird sichergestellt das ausschließlich nicht durch 2,3 und 5 teilbare Zahlen als Primzahlkandidaten weitergehend geprüft werden.
Dazu wird eine Zahl $n \mod 30$ berechnet und der Rest betrachtet.
Ist dieser weder durch 2,3 oder 5 teilbar so ist auch $n$ nicht durch 2,3 oder 5 teilbar.
Andernfalls wird die kleinstmögliche Zahl $k \in \mathbb{N}$ auf $n$ addiert, sodass $n + k \mod 30$ nicht durch 2,3 oder 5 teilbar ist.
Diese kleinstmögliche Zahl ist $adds[n \mod 30]$, das heißt beispielsweise ist $125$ zu $adds[125 \mod 30] = 2$ addiert gleich 127, die kleinstmögliche Zahl größer 125, welche nicht durch 2,3 und 5 teilbar ist.

Mit dieser Methode wird in der Zeile ein Kandidat erzeugt, der nicht durch 2,3 oder 5 teilbar ist und in der Funktion isProbablePrime tiefergehend geprüft wird.
Zuerst wird die Teilerfremdheit von $random\_num -1$ zu dem Exponenten $e$ überprüft (näheres dazu in \ref{RSAGenGCDAttack}).
Danach wird ein einfacher Divisiontest mit alle Primzahlen zwischen 7 und 5000 durchgeführt, wohingegen dieser in Mozilla NSS bereits durch den Siebvorgang abgedeckt ist.
Abschließend wird wie in Mozilla NSS ein Fermat- und Miller-Rabin-Test durchgeführt.

\begin{algorithm}[h]
\DontPrintSemicolon
\caption{Pseudo-Code für Primzahlgenerierung in OpenPGPjs}
\label{alg:randomProbablePrimeOpenPGPjs}
num_miller_rabin_tests <- get_num_tests(bitlen(random\_num))\;
small\_primes <- [7, 11, 13, 17, ..., 4999] //665 primes from 7 to 5000\;

\Fn{$randomProbablePrime(bits, e)$}{
    adds <- [1, 6, 5, 4, 3, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 2, 1, 4, 3, 2, 1, 6, 5, 4, 3, 2, 1, 2]\;
    random\_num <- random.getRandomBN\;
    i <- random\_num mod 30\;
    
    \Repeat{!isProbablePrime(random\_num,e,num_miller_rabin_tests)}{
        random\_num <- random\_num + adds[i]\;
        i <- (i + adds[i]) mod 30\;
        // If reached the maximum, go back to the minimum.\;
        \If{bitlen(random\_num) > bits}{
            random\_num <- (random\_num mod $2^{bits}$) + $2^{bits-1}$\;
            i <- random\_num mod 30\;
        }
    }
}

\Fn{$isProbablePrime(random\_num, e, num\_miller\_rabin\_tests)$}{
    \If{gcd(random\_num-1, e) $\neq$ 1}{
        \Return false\;
    }
    \ForEach{small\_prime in small\_primes}{
        \If{random\_num mod small\_prime = 0}{
            \Return false\;
        }
    }
    \If{!fermat(random\_num, 2)}{
        \Return false\;
    }
    \If{!millerRabin(random\_num, k)}{
        \Return false\;
    }
    \Return true
}
\end{algorithm}

\subsection{Mögliche Leakage in Mozilla NSS}

Das Ziel ist es die Zahl $random\_num$ oder Teile davon zu rekonstruieren.
Der Siebvorgang sticht hier besonders hervor, da dort unabhängig von $random\_num$ genau 6541 (Anzahl der Primzahlen von 3 bis $2^{16}$) Modulo-Operationen mit vorher bekannten Primzahlen auf $random\_num$ ausgeführt werden.

Typische RSA-Schlüssel besitzen heute eine Länge von 2048 Bit, sodass $random\_num$ etwa ein Länge von 1024 Bit besitzt.
Deswegen dauert die Berechnung von $random\_num \mod small\_prime$ im Schnitt TODO Taktzyklen.
Somit ist bekannt, dass auf das $primes\_tab$-Array nur jede TODO Taktzyklen einmal zugegriffen wird.

Das $primes\_tab$-Array ist vom Datentyp mp_digit, der bei einer Linux x64-Kompilierung gleichbedeutend mit ein 8 Byte Integer ist.
Somit hat das $primes_tab$-Array ein Gesamtgröße von $8 \cdot 6541 = 52328 Bytes$ und liegt in $\lceil 52328 / 64 \rceil = 818$ verschiedenen Cache-Lines bzw. $\lceil 52328 / 4096 \rceil = 13$ Pages.

Angenommen die zu primes_tab[0-7] gehörige Cache-Line wird mittels Prime-and-Probe überwacht, dann können nach Start des Siebvorgangs 8 Zugriffe mit jeweils etwa TODO Taktzyklen Abstand gemessen werden.
Nachdem 8. Zugriff muss die überwachte Cache-Line auf $primes\_tab[8-15]$ für weitere 8 Zugriffe gewechselt werden usw.

Um die notwendigen Cache-Sets zu Finden muss nur jeweils ein Cache-Set pro 4-KiB Page identifiziert werden, da wie bereits erwähnt die Adressen innerhalb einer Page identisch sind.
Das Zugriffsmuster auf jede Cache-Lines des $primes\_tab$-Array entspricht immer 8 Zugriffen mit jeweils TODO Taktzyklen Pause. Außerdem liegt das $primes\_tab$-Array immer an der selben Adresse im Speicher.
Die Angreiferin kann selber Schlüsselerzeugungen anstoßen, sodass es ihr möglich ist die passenden Eviction-Sets für das $primes\_tab$-Array zu finden.

Die Schreibzugriff auf das $sieve$-Array in der For-Schleife (siehe \ref{alg:sievePrimeGenerationNSS} Zeile 9-11) sind mit einer Laufzeit von etwa 100 Taktzyklen zu schnell um einzelne Zugriffe unterscheiden zu können.
Das $sieve$-Array ist ein Byte Array der Größe 32768 Bytes und liegt somit in 512 Cache-Lines.
Bei den ersten Iterationen der For-Schleife mit kleinen Primzahlen wie der 3 wird noch auf alle 512 Cache-Lines zugegriffen.
Sobald die Primzahlen aber den Wert 64 überschreiten werden Cache-Sets ausgelassen.

Zur Veranschaulichung hier ein Beispiel:

Angenommen $random\_num \mod 67 = 0$ und die For-Schleife der Zeile 9-11 ist in der 42. Iteration, das heißt $i=2814$ ist gerade.
Dann wird gemäß Zeile 11 $sieve[1407] = 1$ gesetzt, hiermit auf die Cache-Line für $sieve[1344-1407]$ zugegriffen und abschließend $i=2881$ gesetzt.

In der 43. Iteration wird auf keine Cache-Line von $sieve$ zugegriffen, da $i=2881$ ungerade ist.

Die 44. Iteration arbeitet mit $i=2948$ und setzt somit den Wert $sieve[1474] = 1$.
Die zugehörige Cache-Line ist nun $sieve[1472-1535]$, womit keinerlei Zugriff auf die Cache-Line $sieve[1408-1471]$ erfolgt.

Cache-Lines auf die nicht zugegriffen wird können Informationen preisgeben, da das $i$ der For-Schleife in Abhängigkeit der Berechnung $random\_num \mod small\_prime$ definiert wird.

Dies soll an folgendem Beispiel verdeutlicht werden:

Angenommen es wurde ein Zugriff auf die Cache-Line $sieve[64-127]$, aber nicht auf die Cache-Line $sieve[0-63]$ gemessen und $small\_prime$ ist für die aktuelle Iteration bekannt. Festzuhalten ist, dass $i \in \{128,...,254\}$ und gerade sein muss, sodass ein Schreibzugriff auf $sieve[64-127]$ in Zeile 11 ausgeführt wird.
Weiter kann nicht $random\_num \mod small\_prime = 0$ gelten, da ansonsten ein Zugriff auf die Cache-Line $sieve[0-63]$ messbar wäre. 
Es wird nun zwischen verschiedenen Werten für die Variable offset (siehe Zeile 6 und 8 in mpp_sieve) unterschieden.

1. Fall: Sei $offset \in \{128,...,254\}$ und gerade, also $offset \mod 2 = 0$. 

Dann ist $rem = small\_prime - offset$ und durch die Kenntnis von $small\_prime$ und $offset \in \{128,...,254\}$ gerade kann $rem$ auf 64 mögliche Werte eingegrenzt werden.

2. Fall: Sei $offset$ ungerade, also $offset \mod 2 = 1$ und $offset_ex = offset + small_prime \in \{128,...,254\}$ und $offset_ex \mod 2 = 0$. Da $i=offset$ und $offset$ ungerade erfolgt in der ersten Iteration der For-Schleife kein Zugriff auf das $sieve$-Array. Wenn der Zugriff also in der zweiten Iteration erfolgt ist $i = offset + small_prime = offset_ex$.

Da $offset = offset_ex - small_prime$ ist $rem = small_prime - (offset_ex - small_prime) = 2 \cdot small_prime - offset_ex$ und durch die Kenntnis von $small\_prime$ und $offset_ex \in \{128,...,254\}$ gerade kann $rem$ auf 64 mögliche Werte eingegrenzt werden.

Es ist unbekannt ob $rem$ gerade oder ungerade ist, weshalb $rem$ nicht weiter als auf 128 mögliche Werte eingegrenzt werden kann.

Mit dieser Leakage ergeben sich "unscharfe" Kongurrenzen bezüglich des Wertes $random\_num$ der folgenden Form:
\begin{align}
    random\_num \mod small_prime \equiv a, mit a \in A_i
\end{align}
a kann durch diese Leakage nicht exakt bestimmt werden, deshalb ist $A_i$ die Menge mit den möglichen Werten die a annehmen kann.
Im oberen Beispiel gilt etwa $|A_i| = 128$ und $\{128,130,132,...,254\} \subsetneq A_i$.

Die Fallunterscheidung in der Funktion mpp_sieve in den Zeilen 5 bis 8 würde die Information liefern ob $random\_num \mod small\_prime = 0$ ist.
Unabhängig von $rem$ wird aber immer der gesamte Assemblercode für die Zeilen 5 bis 8 geladen \ref{fig:assemblyMppSieve}, da die Vergleichsoperation an Adresse 806A4 und der Code für die folgende For-Schleife an der Adresse 806CA immer benötigt wird.
Der Abstand zwischen den Adressen 806A4 und 806CA ist kleiner als die Größe einer 64 Byte Cache-Line, das heißt die vorherige Aussage ist losgelöst von den Adressen des Codes in der Binary.
Somit ist ein Prime-and-Probe Angriff auf den entsprechenden Codeteil nicht möglich, da sofern der Assemblercode für die Zeile 5 bis 8 in zwei Cache-Lines fällt immer bei beiden eine erhöhte Zugriffszeit gemessen würde.

\begin{figure}[h]
\label{fig:assemblyMppSieve}
\renewcommand\fcolorbox[4][]{\textcolor{black}{\strut#4}}
\small
%00000000000806A4 <For-Schleife Zeile 5 bis 8>:
\begin{minted}{gas}
  806A4:        cmp    [rem], 0
  806AA:        jnz    else
  806AC:        mov    [offset], 0  
  806B4:        jmp    next_code
  806B6: else:  mov    rax, [rem]
  806BB:        mov    rcx, [small\_prime]
  806C0:        sub    rcx, rax
  806C3:        mov    rax, rcx
  806C6:        mov    [offset], eax
  806CA: //Code for line 9
\end{minted}
\normalsize
\caption{Assemblercode für die Zeilen 5 bis 8 der Funktion mpp_sieve}
\end{figure}


\section{Angriffe auf RSA Key Generierung}
\label{RSAGenGCDAttack}

Details zu Implementierung in Mozilla NSS

Mozilla Network Security Services(NSS) ist ein Menge von Bibliotheken, welche eine plattformübergreifende Entwicklung von sicheren Client- und Server-Anwendungen anstrebt. Dabei wird unter anderem TLS oder S/MIME implementiert. Mozilla NSS wird etwa im Firefox-Browser und der Mail-Anwendung Thunderbird eingesetzt.
Der Quellcode ist unter der Mozilla Public License verfügbar und kann online etwa im Firefox-Repository \cite{MozillaDXR} eingesehen werden.

Im folgenden soll die Schlüsselerzeugung für das RSA-Verfahren in Mozilla NSS beschrieben werden.

Der Code zur Schlüsselerzeugung liegt im Unterordner lib/freebl. Sobald die Schlüsselparameter $p,q,n,d,e$ bestimmt wurden, werden diese in der Funktion RSA_PrivateKeyCheck auf Gültigkeit überprüft (siehe Pseudo-Code \ref{alg:RSA_PrivateKeyCheck}).

\begin{algorithm}[h]
\DontPrintSemicolon
\caption{Pseudo-Code für RSA_PrivateKeyCheck aus rsa.c}
\label{alg:RSA_PrivateKeyCheck}

\Fn{$RSA_PrivateKeyCheck(key)$}{
    assert(p $\neq$ q)\;
    assert(n == p * q)\;
    assert(gcd(e, p-1) == 1)\;
    assert(gcd(e, q-1) == 1)\;
    assert(d*e == 1 mod p-1)\;
    assert(d*e == 1 mod q-1)\;
    assert(d_p == d mod p-1)\;
    assert(d_q == d mod q-1)\;
    assert(q * q^-1 == 1 mod p)\;
}
\end{algorithm}

%Ausgehend von der Funktion RSA_NewKey in rsa.c

%\begin{algorithm}[h]
%\DontPrintSemicolon
%\caption{Pseudo-Code für RSA_NewKey aus rsa.c}
%\label{alg:mp_gcd}
%
%\Fn{$RSA_NewKey(keySizeInBits, e)$}{
%    p $rightarrow$ generate_prime(keySizeInBits)\;
%    q $rightarrow$ generate_prime(keySizeInBits)\;
%    d $rightarrow$ rsa_build_from_primes(p,q,e)\;
%}
%\end{algorithm}

Relvant für diese Arbeit sind im Wesentlichen die Zeilen 4 und 5, in denen die Teilerfremdheit von $e$ zu $p-1$ und $q-1$, d.h. $gcd(e,p-1) = 1$ und $gcd(e,q-1) = 1$ geprüft wird.
Aus Performancegründen wird der Exponent $e$, anders als ursprünglich im RSA-Algorithmus beschrieben, auf den Wert 65537 fixiert.
Interessant ist die Funktion $mp_gcd$ (Pseudocode siehe \ref{alg:mp_gcd}), welche den größten gemeinsamen Teiler nach dem binären Verfahren von Josef Strein \cite{} berechnet. Dieser Algorithmus verwendet zum Berechnen des ggT ausschließlich Rechts-Shift-Operationen (Teilen durch 2) und Subtraktionen, wodurch dieser besonders für die in diesem Kontext verwendeten großen Zahlen interessant ist.
Die Zeilen 1 bis 6 der Funktion $mp_gcd$ können in diesem Fall ignoriert werden, da der Exponent $e$ wie oben beschrieben immer 65537 und damit ungerade ist. Bedeutender hingegen ist die $while$-Schleife in den Zeilen 11 bis 17, welche abhängig von den Eingaben Fallunterscheidungen durchführt. Das Ziel ist hier, die Rechts-Shift-Operation (Zeile 13) von der Subtraktionsfunktion (Zeile 17) zu unterscheiden, um die Zustände während der Berechnung zu rekonstruieren. \todo{hier fehlt der verweis auf das paper}

\begin{algorithm}[h]
\DontPrintSemicolon
\caption{Pseudo-Code für mp_gcd nach Josef Stein}
\label{alg:mp_gcd}

\Fn{$mp_gcd(u,v)$}{
    k $\leftarrow$ 0\;
    \While{iseven(u) \& iseven(v)}{
        u $\leftarrow$ u/2\;
        v $\leftarrow$ v/2\;
        k++\;
    }

    \If{isodd(u)}{
        t $\leftarrow$ -v\;
    } \Else {
        t $\leftarrow$ v\;
    }

    \While{t $\neq$ 0}{
        \While{iseven(t)}{
            t $\leftarrow$ t/2\;
        }
        \If{t > 0} {
            u $\leftarrow$ t\;
        } else {
            v $\leftarrow$ -t\;
        }
        t $\leftarrow$ u - v\;
    }

    \Return u*2^k
}
\end{algorithm}

TODO beschreiben warum der angriff so nicht in wasm/js möglich ist, warum er in c möglich ist, clflush vs prime spam usw.

rsa und storeforward näher zu kapiteln bringen anstatt in grundlagen?
speicher deduplizierung?
grundlagen ganz vorner hier gehört die erklärung des themas hin, sowie relvanz für die forschuing
titel anpassen