results:
\todo{schreib bitte in die Bildunterschrift mit rein, was man hier sieht. Das gilt für alle Abbildungen, wo du das noch nicht tust}

TODOs:
Seite 3, messen wie schnell slot time von c code am besten unter last, nutze victim
Seite 3, Peroframnce von StoreFor vs Standard schreieben
Seite 13, Differenz von Cache-Hit vs Miss auf Testsystem messen
Eventuell 4800 Taktzyklen (mittlere Dauer einer Iteration von \textit{mpp_sieve} bei RSA 2048) prüfen
Eventuell Die Berechnung von $\text{\textit{random_num}} \mod \text{\textit{small\_prime}}$ dauert dann im Schnitt 4800 Taktzyklen. prüfen
Eventuell Somit ist bekannt, dass auf das \textit{primes_tab}-Array nur etwa jede 4800 Taktzyklen einmal zugegriffen wird.
Eventuell Das Zugriffsmuster auf jeder Cache-Line des \textit{primes_tab}-Array entspricht immer 8 Zugriffen mit jeweils etwa 4800 Taktzyklen Pause
Eventuell Durch die Berechnung von $\text{\textit{random_num}} \mod \text{\textit{small_prime}}$ entsteht zwischen den Zugriffen auf das \textit{sieve}-Array eine Pause von etwa 4800 Taktzyklen.


Seite 46:
Es steht die Frage im Raum, wie viele Gleichungen für die vollständige Rekonstruktion einer Primzahl benötigt werden.
Für den Informationsgehalt der zweiten Gleichung ist die mittlere Größe von $\text{\textit{small_prime}}_i$ ausschlaggebend.
Tabelle %\ref{} TODO
zeigt die zu erwartenden Werte für verschiedene Primzahlbitlängen. 
\todo{prüfen wie sich verhalten mit unterschiedlichen bitlängen verändert}

Seite 48: MEssen wie viele Primzahl in Openpgp.js durchprobiert werden
Erschwerend ist außerdem, dass die Schleife in den Zeilen 7 bis 14 im Mittel nur TODO mal ausgeführt wird und somit die Zugriffe auf das \textit{adds}-Array nach oben begrenzt sind.

Seite 59: TODO auf nuc testen.







(Wo kommen die Antworten auf die vier Eingangsfragen? Struktur der Arbeit inkl. Fazit ist mir nicht ganz klar; vielleicht rekurrierst du auf die Fragen im Fazit direkt, wenn es strukturell Sinn ergibt?)



Prüfen: Initialisierungsdauer linear mit der Anzahl der Angriffsinstanzen nope

%(fixen)
Aufgrund des Fehlens eines Beweises für die NP-Schwere oder eines effizienten Lösungsalgorithmus' ist dem Autor die Komplexität dieses Problems bewusst.


Algorithmus zu Pseudocode umbenennen

Auf dem Testsystem mit einem Intel i7-4770 und DDR3-1600 RAM konnten etwa Differenzen von TODO gemessen werden.


eventuell fälle in identifikation von angriffszielen leakage analyse mit grafik siehe korrektur seite 42

"Aufgrund des Fehlens eines Beweises für die NP-Schwere oder eines effizienten Lösungsalgorithmus' ist dem Autor die Problemkomplexität unbekannt."
eventuell umformulieren

Optimierung der Phasen mehr stuff


Kapitel Implementation:
Benchmark zu Eviction-Set Suche vervollständigen
Probleme mit Timer evaluieren
Vervollständigung von Optimierung der Phasen (Contract init value)
Vervollständigung von Details der realen Implment
Vervollständigung von StoreForward

Kapitel Identifikation von Angriffszielen:


Diskussion:


Schätze ab wann ein Angriff auf mp_gcd möglich wäre (evaluerien mit delay parameter)\\




anführungszeichen fixen „Sub“





check: 01.10: Prime and Probe überall zu Prime-and-Probe geändert
01.10 : colliding address zu colliding-address

Masse erzeugen:
Beschreibung von Jan Tool und die Ergebnisse davon
Wenn dann einleitungssatz hinzufügen
%Zum Einsatz kam dabei ein Werkzeug (Welches ist das? Wie heißt es?), welches automatisch potenzielle Leakages aufdeckt.

Verwandete Arbeiten mehr über RSA-Angriff schreiben siehe TODO
Analyse der Mod-Funktion (optional)
Analyse der Miller-Rabin-Funktion (optional)
Eventuell: Vergleiche Bremsverhalten mit clflush in native c code,
Achtung aufwendig da Eviction-Set Zuordnung in c implementiert werden muss


%kopfzeile tabelle absetzen
%einleitung ~4-6 (related work)
%schluss ~3-4

%4/7 sollte neuer content sein