results:
\todo{schreib bitte in die Bildunterschrift mit rein, was man hier sieht. Das gilt für alle Abbildungen, wo du das noch nicht tust}

TODOs:
Seite 3, messen wie schnell slot time von c code am besten unter last, nutze victim

Seite 13, Differenz von Cache-Hit vs Miss auf Testsystem messen
Auf dem Testsystem mit einem Intel i7-4770 und DDR3-1600 RAM konnten etwa Differenzen von TODO gemessen werden.

Eventuell 4800 Taktzyklen (mittlere Dauer einer Iteration von \textit{mpp_sieve} bei RSA 2048) prüfen
Eventuell Die Berechnung von $\text{\textit{random_num}} \mod \text{\textit{small\_prime}}$ dauert dann im Schnitt 4800 Taktzyklen. prüfen
Eventuell Somit ist bekannt, dass auf das \textit{primes_tab}-Array nur etwa jede 4800 Taktzyklen einmal zugegriffen wird.
Eventuell Das Zugriffsmuster auf jeder Cache-Line des \textit{primes_tab}-Array entspricht immer 8 Zugriffen mit jeweils etwa 4800 Taktzyklen Pause
Eventuell Durch die Berechnung von $\text{\textit{random_num}} \mod \text{\textit{small_prime}}$ entsteht zwischen den Zugriffen auf das \textit{sieve}-Array eine Pause von etwa 4800 Taktzyklen.


Seite 46:
Prüfe Tabelle 4.1 Differenzen zu praktischen Ergebnissen (praktisch doppelt so viele versuche!)

rounds do while	early break	small_prime mean bitlen		bitlen
240	174	5,17		1024
226	175	5,46		
583	426	5,33		
195	146	5,35		
430	326	5,47		
333	251	5,45		
56	44	5,62		
14	11	5,39		
15	10	4,69		
1032	784	5,42		
312,4	234,7	5,335		
	0,7512804097			
237	175	5,24		2048
322	236	5,32		
568	429	5,43		
311	224	5,27		
266	191	5,3		
722	550	5,4		
425	319	5,47		
76	59	5,38		
1813	1379	5,45		
95	76	5,41		
483,5	363,8	5,367		
	0,7524301965			

Seite 59: TODO auf nuc testen.



geschwindigkeit von parallelen prime probe



(Wo kommen die Antworten auf die vier Eingangsfragen? Struktur der Arbeit inkl. Fazit ist mir nicht ganz klar; vielleicht rekurrierst du auf die Fragen im Fazit direkt, wenn es strukturell Sinn ergibt?)



Prüfen: Initialisierungsdauer linear mit der Anzahl der Angriffsinstanzen nope

%(fixen)
Aufgrund des Fehlens eines Beweises für die NP-Schwere oder eines effizienten Lösungsalgorithmus' ist dem Autor die Komplexität dieses Problems bewusst.


eventuell fälle in identifikation von angriffszielen leakage analyse mit grafik siehe korrektur seite 42

"Aufgrund des Fehlens eines Beweises für die NP-Schwere oder eines effizienten Lösungsalgorithmus' ist dem Autor die Problemkomplexität unbekannt."
eventuell umformulieren

Optimierung der Phasen mehr stuff


Kapitel Implementation:
Benchmark zu Eviction-Set Suche vervollständigen
Probleme mit Timer evaluieren
Vervollständigung von Optimierung der Phasen (Contract init value)
Vervollständigung von Details der realen Implment
Vervollständigung von StoreForward

Kapitel Identifikation von Angriffszielen:


Diskussion:


Schätze ab wann ein Angriff auf mp_gcd möglich wäre (evaluerien mit delay parameter)\\




anführungszeichen fixen „Sub“





check: 01.10: Prime and Probe überall zu Prime-and-Probe geändert
01.10 : colliding address zu colliding-address

Masse erzeugen:
Beschreibung von Jan Tool und die Ergebnisse davon
Wenn dann einleitungssatz hinzufügen
%Zum Einsatz kam dabei ein Werkzeug (Welches ist das? Wie heißt es?), welches automatisch potenzielle Leakages aufdeckt.

Verwandete Arbeiten mehr über RSA-Angriff schreiben siehe TODO
Analyse der Mod-Funktion (optional)
Analyse der Miller-Rabin-Funktion (optional)
Eventuell: Vergleiche Bremsverhalten mit clflush in native c code,
Achtung aufwendig da Eviction-Set Zuordnung in c implementiert werden muss


%kopfzeile tabelle absetzen
%einleitung ~4-6 (related work)
%schluss ~3-4

%4/7 sollte neuer content sein